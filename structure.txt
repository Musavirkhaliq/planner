.
├── app
│   ├── auth.py
│   ├── config.py
│   ├── crud.py
│   ├── database.py
│   ├── dependencies.py
│   ├── __init__.py
│   ├── main.py
│   ├── models.py
├── app.db
├── frontend
│   ├── static
│   │   ├── script.js
│   │   └── style.css
│   └── templates
│       ├── analytics.html
│       ├── dashboard.html
│       ├── index.html
│       ├── login.html
│       └── register.html
├── __init__.py
├── makedir.py
├── README.md
├── requirements.txt
└── structure.txt

\n\n./__init__.py:\n
from app.database import Base, engine

# Drop all tables and recreate them
Base.metadata.drop_all(bind=engine)
Base.metadata.create_all(bind=engine)
\n\n./frontend/static/script.js:\n
// frontend/static/script.js

// ---------- LOGIN & REGISTER FUNCTIONS -----------
async function submitForm(e, url, formData, isJson = true) {
    e.preventDefault();
    try {
        const response = await fetch(url, {
            method: "POST",
            headers: isJson ? { "Content-Type": "application/json" } : { "Content-Type": "application/x-www-form-urlencoded" },
            body: isJson ? JSON.stringify(formData) : new URLSearchParams(formData)
        });
        if (response.ok) {
            return await response.json();
        } else {
            const errorData = await response.json();
            alert(`Error: ${errorData.detail || "Unknown error"}`);
        }
    } catch (error) {
        console.error("Error during form submission:", error);
        alert("An error occurred. Please try again.");
    }
}

// Login Form Submission
document.getElementById("loginForm")?.addEventListener("submit", async (e) => {
    const email = document.getElementById("email").value;
    const password = document.getElementById("password").value;
    const data = await submitForm(e, "/token", { username: email, password: password }, false);
    if (data && data.access_token) {
        localStorage.setItem("access_token", data.access_token);
        window.location.href = "/dashboard";
    }
});

// Register Form Submission
document.getElementById("registerForm")?.addEventListener("submit", async (e) => {
    const email = document.getElementById("email").value;
    const password = document.getElementById("password").value;
    const data = await submitForm(e, "/users/", { email, password });
    if (data) window.location.href = "/login";
});

// ---------- DASHBOARD FUNCTIONS -----------
async function fetchWithAuth(url, options = {}) {
    const token = localStorage.getItem("access_token");
    if (!token) {
        window.location.href = "/login";
        return;
    }
    options.headers = {
        ...(options.headers || {}),
        "Authorization": `Bearer ${token}`
    };
    return await fetch(url, options);
}

// Time Slot Booking
async function bookTimeSlot() {
    const task = document.getElementById("task").value;
    const startTime = document.getElementById("startTime").value;
    const endTime = document.getElementById("endTime").value;
    // Create a description from the task
    const description = task;
    const response = await fetchWithAuth("/time_slots/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ start_time: startTime, end_time: endTime, description })
    });
    if (response && response.ok) {
        window.location.reload();
    } else {
        alert("Failed to book time slot");
    }
}

// Goals & Breakdown: add a goal
async function addGoal() {
    const goal = document.getElementById("goal").value;
    if (!goal) return;
    const response = await fetchWithAuth("/goals/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ title: goal, description: "" })
    });
    if (response && response.ok) {
        window.location.reload();
    } else {
        alert("Failed to add goal");
    }
}

// Load Tasks for the To-Do List
document.addEventListener("DOMContentLoaded", async () => {
    // Load tasks into the taskList element if present
    const taskList = document.getElementById("taskList");
    if (taskList) {
        const response = await fetchWithAuth("/tasks/");
        if (response.ok) {
            const tasks = await response.json();
            tasks.forEach(task => {
                const li = document.createElement("li");
                li.textContent = `${task.title}: ${task.description} - Time Spent: ${task.time_spent} hours`;
                taskList.appendChild(li);
            });
        } else {
            alert("Failed to fetch tasks");
        }
    }

    // Load Analytics Chart if canvas present
    const chartCanvas = document.getElementById("productivityChart");
    if (chartCanvas) {
        const response = await fetchWithAuth("/analytics/");
        if (response.ok) {
            const analytics = await response.json();
            // Using Chart.js (make sure to include its script in your HTML)
            new Chart(chartCanvas, {
                type: 'bar',
                data: {
                    labels: ['Total Tasks', 'Completed Tasks', 'Time Spent (hrs)'],
                    datasets: [{
                        label: 'Productivity Analytics',
                        data: [analytics.total_tasks, analytics.completed_tasks, analytics.total_time_spent],
                        backgroundColor: ['#007BFF', '#28a745', '#ffc107']
                    }]
                }
            });
        }
    }
});

// ---------- POMODORO TIMER -----------
let workTime = 25 * 60; // default 25 minutes (can be made configurable)
let breakTime = 5 * 60; // default 5 minutes break
let isWorking = true;

function startTimer(duration, display) {
    let timer = duration, minutes, seconds;
    const interval = setInterval(function () {
        minutes = parseInt(timer / 60, 10);
        seconds = parseInt(timer % 60, 10);
        display.textContent = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
        if (--timer < 0) {
            isWorking = !isWorking;
            timer = isWorking ? workTime : breakTime;
            alert(isWorking ? "Time to work!" : "Time for a break!");
        }
    }, 1000);
}

window.onload = function () {
    const display = document.querySelector('#time');
    if (display) {
        startTimer(workTime, display);
    }
};
// frontend/static/script.js

document.addEventListener("DOMContentLoaded", () => {
    initAuth();
    initTimeSlotForm();
    initBookingDatePicker();
    // Initially load bookings for today
    const today = new Date().toISOString().split("T")[0];
    document.getElementById("bookingDate").value = today;
    loadTimeSlotsByDate(today);
    // ... (other initializations, e.g., goals, pomodoro, analytics)
  });
  
  // ---------- AUTH FUNCTIONS ----------
  function initAuth() {
    const logoutBtn = document.getElementById("logoutBtn");
    if (logoutBtn) {
      logoutBtn.addEventListener("click", () => {
        localStorage.removeItem("access_token");
        window.location.href = "/login";
      });
    }
  }
  
  // ---------- TIME SLOT BOOKING FUNCTIONS ----------
  
  // Initialize date picker to reload table when a new date is chosen.
  function initBookingDatePicker() {
    const bookingDateInput = document.getElementById("bookingDate");
    if (bookingDateInput) {
      bookingDateInput.addEventListener("change", (e) => {
        loadTimeSlotsByDate(e.target.value);
      });
    }
  }
  
  // Submit the new time slot form.
  function initTimeSlotForm() {
    const timeSlotForm = document.getElementById("timeSlotForm");
    if (timeSlotForm) {
      timeSlotForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const startTime = document.getElementById("startTime").value;
        const endTime = document.getElementById("endTime").value;
        const task = document.getElementById("task").value;
        const bookingDate = document.getElementById("bookingDate").value;
        const token = localStorage.getItem("access_token");
  
        const payload = {
          start_time: `${bookingDate}T${startTime}`,
          end_time: `${bookingDate}T${endTime}`,
          description: task,
          date: bookingDate  // assuming the API accepts a date field
        };
  
        const response = await fetch("/time_slots/", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(payload),
        });
  
        if (response.ok) {
          timeSlotForm.reset();
          // Reapply the selected date (if the reset clears it)
          document.getElementById("bookingDate").value = bookingDate;
          loadTimeSlotsByDate(bookingDate);
        } else {
          alert("Failed to add time slot");
        }
      });
    }
  }
  
  // Load time slots for the selected date.
  async function loadTimeSlotsByDate(date) {
    const token = localStorage.getItem("access_token");
    // Assuming the API supports filtering by date: /time_slots/?date=YYYY-MM-DD
    const response = await fetch(`/time_slots/?date=${date}`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    if (response.ok) {
      const slots = await response.json();
      renderTimeSlotTable(slots);
    } else {
      alert("Failed to load time slots");
    }
  }
  
  // Render the time slot table rows.
  function renderTimeSlotTable(slots) {
    const tableBody = document.querySelector("#timeSlotTable tbody");
    tableBody.innerHTML = "";
  
    slots.forEach((slot) => {
      // Calculate total allotted minutes from start and end times.
      const start = new Date(slot.start_time);
      const end = new Date(slot.end_time);
      const allottedMinutes = Math.round((end - start) / 60000); // convert ms to minutes
  
      // Use the stored "report" (in minutes) if available; otherwise default to 0.
      const reportedMinutes = slot.report_minutes || 0;
      const progressPercent = Math.min(
        100,
        Math.round((reportedMinutes / allottedMinutes) * 100)
      );
      const ratingStars = "★".repeat(Math.max(1, Math.round(progressPercent / 20)));
  
      const tr = document.createElement("tr");
      tr.setAttribute("data-slot-id", slot.id);
  
      // TIME (formatted as e.g., 06:00AM-07:00AM)
      const timeTd = document.createElement("td");
      timeTd.textContent = `${start.toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      })} - ${end.toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      })}`;
      tr.appendChild(timeTd);
  
      // DONE? (checkbox – optionally update on click)
      const doneTd = document.createElement("td");
      const doneCheckbox = document.createElement("input");
      doneCheckbox.type = "checkbox";
      doneCheckbox.checked = slot.done || false;
      doneCheckbox.addEventListener("change", () => {
        updateTimeSlotField(slot.id, { done: doneCheckbox.checked });
      });
      doneTd.appendChild(doneCheckbox);
      tr.appendChild(doneTd);
  
      // TO-DO LIST (Task description)
      const descTd = document.createElement("td");
      descTd.textContent = slot.description;
      tr.appendChild(descTd);
  
      // REPORT (Min) – input for minutes reported
      const reportTd = document.createElement("td");
      const reportInput = document.createElement("input");
      reportInput.type = "number";
      reportInput.min = 0;
      reportInput.value = reportedMinutes;
      reportInput.className = "form-control form-control-sm";
      reportInput.style.width = "80px";
      // Update the booking when the report input loses focus
      reportInput.addEventListener("change", () => {
        updateTimeSlotReport(slot.id, parseInt(reportInput.value), allottedMinutes);
      });
      reportTd.appendChild(reportInput);
      tr.appendChild(reportTd);
  
      // PROGRESS – a Bootstrap progress bar
      const progressTd = document.createElement("td");
      const progressDiv = document.createElement("div");
      progressDiv.className = "progress";
      const progressBar = document.createElement("div");
      progressBar.className = "progress-bar";
      progressBar.style.width = `${progressPercent}%`;
      progressBar.textContent = `${progressPercent}%`;
      progressDiv.appendChild(progressBar);
      progressTd.appendChild(progressDiv);
      tr.appendChild(progressTd);
  
      // RATING – display star icons
      const ratingTd = document.createElement("td");
      ratingTd.textContent = ratingStars;
      tr.appendChild(ratingTd);
  
      tableBody.appendChild(tr);
    });
  }
  
  // When the report minutes input changes, update the booking.
  async function updateTimeSlotReport(slotId, reportMinutes, allottedMinutes) {
    const token = localStorage.getItem("access_token");
    // Calculate progress & rating on the front end for immediate feedback.
    const progressPercent = Math.min(
      100,
      Math.round((reportMinutes / allottedMinutes) * 100)
    );
    // Build star rating: use at least 1 star.
    const ratingStars = "★".repeat(Math.max(1, Math.round(progressPercent / 20)));
  
    // Find the row in the table and update its progress bar and rating cells.
    const row = document.querySelector(`tr[data-slot-id="${slotId}"]`);
    if (row) {
      const progressBar = row.children[4].querySelector(".progress-bar");
      progressBar.style.width = `${progressPercent}%`;
      progressBar.textContent = `${progressPercent}%`;
      row.children[5].textContent = ratingStars;
    }
  
    // Send the updated report value to the back‑end.
    // (Assuming your back‑end supports PATCH updates for time slot bookings.)
    const response = await fetch(`/time_slots/${slotId}`, {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ report_minutes: reportMinutes }),
    });
    if (!response.ok) {
      alert("Failed to update report minutes");
    }
  }
  
  // Update a single field (for example, the "done" status) of a booking.
  async function updateTimeSlotField(slotId, updatePayload) {
    const token = localStorage.getItem("access_token");
    const response = await fetch(`/time_slots/${slotId}`, {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify(updatePayload),
    });
    if (!response.ok) {
      alert("Failed to update time slot");
    }
  }
  


  async function updateTimeSlotField(slotId, updatedData) {
    const token = localStorage.getItem("access_token");
  
    const response = await fetch(`/time_slots/${slotId}`, {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify(updatedData),
    });
  
    if (!response.ok) {
      alert("Failed to update time slot");
    }
  }
  \n\n./frontend/templates/index.html:\n
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Productivity Planner</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="static/style.css">
  
</head>
<body>
  <!-- Background shapes -->
  <div class="bg-shape shape-1"></div>
  <div class="bg-shape shape-2"></div>

  <nav class="navbar navbar-expand-lg navbar-light">
    <div class="container">
      <a class="navbar-brand" href="/">Productivity Planner</a>
      <div class="d-flex">
        <a class="nav-link" href="/login">Login</a>
        <a class="nav-link" href="/register">Register</a>
      </div>
    </div>
  </nav>

  <main class="container">
    <div class="hero-section">
      <h1 class="hero-title">Master Your Time</h1>
      <p class="hero-subtitle">Transform your productivity with our intelligent planning tools. Stay organized, focused, and achieve more every day.</p>
      <div class="d-flex justify-content-center gap-3">
        <a href="/login" class="btn btn-primary">Get Started</a>
        <a href="/register" class="btn btn-outline-primary">Create Account</a>
      </div>
    </div>

    <div class="row mt-5">
      <div class="col-md-4">
        <div class="feature-card">
          <h3 class="h4 mb-3">Smart Time Tracking</h3>
          <p class="text-muted mb-0">Monitor your daily activities and get insights into your productivity patterns.</p>
        </div>
      </div>
      <div class="col-md-4">
        <div class="feature-card">
          <h3 class="h4 mb-3">Focus Timer</h3>
          <p class="text-muted mb-0">Stay focused with our Pomodoro timer and break down your work into manageable sessions.</p>
        </div>
      </div>
      <div class="col-md-4">
        <div class="feature-card">
          <h3 class="h4 mb-3">Analytics Dashboard</h3>
          <p class="text-muted mb-0">Visualize your progress and identify areas for improvement with detailed analytics.</p>
        </div>
      </div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>\n\n./frontend/templates/register.html:\n
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Register | Productivity Planner</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="static/style.css">
</head>
<body>
  <nav class="navbar navbar-light">
    <div class="container">
      <a class="navbar-brand" href="/">Productivity Planner</a>
    </div>
  </nav>

  <main class="container">
    <div class="row justify-content-center align-items-center" style="min-height: 80vh;">
      <div class="col-md-5">
        <div class="register-card">
          <div class="card-body p-4 p-md-5">
            <h2 class="card-title text-center">Create Account</h2>
            <form id="registerForm">
              <div class="mb-4">
                <label for="email" class="form-label">Email address</label>
                <input
                  type="email"
                  class="form-control"
                  id="email"
                  name="email"
                  placeholder="Enter your email"
                  required
                />
              </div>
              <div class="mb-4">
                <label for="password" class="form-label">Password</label>
                <input
                  type="password"
                  class="form-control"
                  id="password"
                  name="password"
                  placeholder="Create a password"
                  required
                />
                <div class="password-requirements">
                  Password must be at least 8 characters long and include numbers and special characters.
                </div>
              </div>
              <button type="submit" class="btn btn-primary w-100 mb-3">
                Create Account
              </button>
            </form>
            <p class="text-center mb-0">
              Already have an account?
              <a href="/login" class="login-link">Login here</a>
            </p>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="/static/script.js"></script>
</body>
</html>\n\n./frontend/templates/login.html:\n
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Login | Productivity Planner</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="static/style.css">
</head>
<body>
  <nav class="navbar navbar-light">
    <div class="container">
      <a class="navbar-brand" href="/">Productivity Planner</a>
    </div>
  </nav>

  <main class="container">
    <div class="row justify-content-center align-items-center" style="min-height: 80vh;">
      <div class="col-md-5">
        <div class="login-card">
          <div class="card-body p-4 p-md-5">
            <h2 class="card-title text-center">Welcome Back</h2>
            <form id="loginForm">
              <div class="mb-4">
                <label for="email" class="form-label">Email address</label>
                <input
                  type="email"
                  class="form-control"
                  id="email"
                  name="email"
                  placeholder="Enter your email"
                  required
                />
              </div>
              <div class="mb-4">
                <label for="password" class="form-label">Password</label>
                <input
                  type="password"
                  class="form-control"
                  id="password"
                  name="password"
                  placeholder="Enter your password"
                  required
                />
              </div>
              <button type="submit" class="btn btn-primary w-100 mb-3">
                Sign In
              </button>
            </form>
            <p class="text-center mb-0">
              Don't have an account?
              <a href="/register" class="register-link">Register here</a>
            </p>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="/static/script.js"></script>
</body>
</html>\n\n./frontend/templates/dashboard.html:\n
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard | Productivity Planner</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="static/style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-light fixed-top">
    <div class="container-fluid">
      <a class="navbar-brand" href="/">Productivity Planner</a>
      <div class="ms-auto">
        <button class="btn btn-outline-danger btn-sm" id="logoutBtn">Logout</button>
      </div>
    </div>
  </nav>

  <main class="container" style="margin-top: 6rem;">
    <div class="row g-4">
      <section class="col-12">
        <div class="card">
          <div class="card-header py-3">
            <div class="d-flex justify-content-between align-items-center">
              <h5 class="card-title mb-0 fw-bold">Time Slot Booking</h5>
              <div class="d-flex align-items-center">
                <label for="bookingDate" class="form-label me-2 mb-0">Select Date:</label>
                <input type="date" id="bookingDate" class="form-control form-control-sm w-auto" />
              </div>
            </div>
          </div>
          <div class="card-body">
            <form id="timeSlotForm" class="row g-3 mb-4">
              <div class="col-md-3">
                <label for="startTime" class="form-label">Start Time</label>
                <input type="time" id="startTime" class="form-control" required />
              </div>
              <div class="col-md-3">
                <label for="endTime" class="form-label">End Time</label>
                <input type="time" id="endTime" class="form-control" required />
              </div>
              <div class="col-md-4">
                <label for="task" class="form-label">Task Description</label>
                <input type="text" id="task" class="form-control" placeholder="Enter task details" required />
              </div>
              <div class="col-md-2 d-flex align-items-end">
                <button type="submit" class="btn btn-primary w-100">Add Slot</button>
              </div>
            </form>

            <div class="table-responsive">
              <table class="table table-hover" id="timeSlotTable">
                <thead>
                  <tr>
                    <th scope="col">TIME</th>
                    <th scope="col">DONE?</th>
                    <th scope="col">TO-DO LIST</th>
                    <th scope="col">REPORT (Min)</th>
                    <th scope="col">PROGRESS</th>
                    <th scope="col">RATING</th>
                  </tr>
                </thead>
                <tbody>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>

      <div class="col-lg-6">
        <div class="card">
          <div class="card-header py-3 d-flex justify-content-between align-items-center">
            <h5 class="card-title mb-0 fw-bold">Focus Timer</h5>
            <div>
              <button class="btn btn-sm btn-primary" id="startTimerBtn">Start</button>
              <button class="btn btn-sm btn-outline-secondary ms-2" id="resetTimerBtn">Reset</button>
            </div>
          </div>
          <div class="card-body text-center py-5">
            <div id="time">25:00</div>
          </div>
        </div>
      </div>

      <div class="col-12">
        <div class="card">
          <div class="card-header py-3">
            <h5 class="card-title mb-0 fw-bold">Productivity Analytics</h5>
          </div>
          <div class="card-body">
            <canvas id="productivityChart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="/static/script.js"></script>
</body>
</html>\n\n./frontend/templates/analytics.html:\n
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Analytics | Productivity Planner</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <main class="container mt-5">
    <h2 class="mb-4">Analytics</h2>

    <div class="row mb-4">
      <div class="col-md-3">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate" class="form-control">
      </div>
      <div class="col-md-3">
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate" class="form-control">
      </div>
      <div class="col-md-3">
        <label>&nbsp;</label>
        <button class="btn btn-primary w-100" onclick="fetchAnalytics()">Get Analytics</button>
      </div>
    </div>

    <canvas id="customAnalyticsChart"></canvas>
  </main>

  <script>
    function fetchAnalytics() {
        const startDate = document.getElementById("startDate").value;
        const endDate = document.getElementById("endDate").value;

        if (!startDate || !endDate) {
            alert("Please select a date range.");
            return;
        }

        fetch(`/analytics?start=${startDate}&end=${endDate}`)
            .then(response => response.json())
            .then(data => updateCustomAnalyticsChart(data))
            .catch(error => console.error("Error fetching analytics:", error));
    }

    function updateCustomAnalyticsChart(data) {
        const ctx = document.getElementById("customAnalyticsChart").getContext("2d");
        new Chart(ctx, {
            type: "line",
            data: {
                labels: data.labels,
                datasets: [{
                    label: "Minutes Focused",
                    data: data.minutes,
                    backgroundColor: "rgba(255, 99, 132, 0.6)",
                    borderColor: "rgba(255, 99, 132, 1)",
                    borderWidth: 1,
                    fill: false
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: { beginAtZero: true }
                }
            }
        });
    }
  </script>
</body>
</html>
\n\n./app/config.py:\n
from pydantic import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./app.db"
    SECRET_KEY: str = "your-secret-key"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

settings = Settings()\n\n./app/utils.py:\n
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)\n\n./app/auth.py:\n
# app/auth.py
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from fastapi import Depends, HTTPException, status
from jose import JWTError, jwt
from datetime import datetime, timedelta
from .config import settings
from . import schemas, crud, models
from .dependencies import get_db  # use shared dependency
from sqlalchemy.orm import Session
from .utils import verify_password  # use our password utility

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta if expires_delta else timedelta(minutes=15))
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_user(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        token_data = schemas.TokenData(email=email)
    except JWTError:
        raise credentials_exception
    user = crud.get_user_by_email(db, email=token_data.email)
    if user is None:
        raise credentials_exception
    return user
\n\n./app/__init__.py:\n
from app.database import Base, engine

# Drop all tables and recreate them
Base.metadata.drop_all(bind=engine)
Base.metadata.create_all(bind=engine)
\n\n./app/schemas.py:\n
# app/schemas.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class UserBase(BaseModel):
    email: str

class UserCreate(UserBase):
    password: str

class User(UserBase):
    id: int
    is_active: bool

    class Config:
        orm_mode = True

class TokenData(BaseModel):
    email: str | None = None

class TaskBase(BaseModel):
    title: str
    description: str

class TaskCreate(TaskBase):
    pass

# New: for updating a task (e.g. marking complete, updating time spent)
class TaskUpdate(BaseModel):
    completed: bool | None = None
    time_spent: float | None = None

class Task(TaskBase):
    id: int
    completed: bool
    time_spent: float
    owner_id: int

    class Config:
        orm_mode = True

class GoalBase(BaseModel):
    title: str
    description: str

class GoalCreate(GoalBase):
    pass

class Goal(GoalBase):
    id: int
    completed: bool
    owner_id: int

    class Config:
        orm_mode = True

class GoalStepBase(BaseModel):
    title: str

class GoalStepCreate(GoalStepBase):
    pass

class GoalStep(GoalStepBase):
    id: int
    completed: bool
    goal_id: int

    class Config:
        orm_mode = True

class TimeSlotBase(BaseModel):
    start_time: datetime
    end_time: datetime
    description: str

class TimeSlotCreate(TimeSlotBase):
    pass

class TimeSlot(TimeSlotBase):
    id: int
    owner_id: int

    class Config:
        orm_mode = True

# New: Dashboard settings schema stub
class DashboardSettings(BaseModel):
    theme: str = "light"
    layout: str = "daily"  # could be "daily", "weekly", or "monthly"

class TimeSlotUpdate(BaseModel):
    report_minutes: Optional[int] = None
    done: Optional[bool] = None\n\n./app/main.py:\n
# app/main.py
from fastapi import FastAPI, Depends, HTTPException, Request, status
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from sqlalchemy.orm import Session
from datetime import timedelta, datetime
from . import crud, models, schemas, auth
from fastapi.security import OAuth2PasswordRequestForm
from .dependencies import get_db

from app import models, database
models.Base.metadata.create_all(bind=database.engine)


app = FastAPI()



# Mount static files and templates
app.mount("/static", StaticFiles(directory="frontend/static"), name="static")
templates = Jinja2Templates(directory="frontend/templates")

# Root endpoints to serve pages
@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.get("/login", response_class=HTMLResponse)
async def read_login(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

@app.get("/register", response_class=HTMLResponse)
async def read_register(request: Request):
    return templates.TemplateResponse("register.html", {"request": request})

@app.get("/dashboard", response_class=HTMLResponse)
async def read_dashboard(request: Request):
    return templates.TemplateResponse("dashboard.html", {"request": request})

# Login endpoint: now actually checks the password!
@app.post("/token")
async def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = crud.get_user_by_email(db, email=form_data.username)
    if not user or not auth.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(status_code=400, detail="Incorrect email or password")
    access_token = auth.create_access_token(data={"sub": user.email}, expires_delta=timedelta(minutes=30))
    return {"access_token": access_token, "token_type": "bearer"}

@app.post("/users/", response_model=schemas.User)
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    db_user = crud.get_user_by_email(db, email=user.email)
    if db_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    return crud.create_user(db=db, user=user)

@app.get("/users/{user_id}", response_model=schemas.User)
def read_user(user_id: int, db: Session = Depends(get_db)):
    db_user = crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

# Task endpoints: creation, reading, and updating (time spent and completion)
@app.post("/tasks/", response_model=schemas.Task)
def create_task(
    task: schemas.TaskCreate,
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    return crud.create_task(db=db, task=task, user_id=current_user.id)

@app.get("/tasks/", response_model=list[schemas.Task])
def read_tasks(
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    return crud.get_tasks(db=db, user_id=current_user.id)

@app.patch("/tasks/{task_id}", response_model=schemas.Task)
def update_task(
    task_id: int,
    task_update: schemas.TaskUpdate,  # see schemas update below
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    db_task = crud.get_task(db, task_id=task_id, user_id=current_user.id)
    if not db_task:
        raise HTTPException(status_code=404, detail="Task not found")
    return crud.update_task(db=db, task=db_task, task_update=task_update)

# Goal endpoints (creation, reading, and adding steps)
@app.post("/goals/", response_model=schemas.Goal)
def create_goal(
    goal: schemas.GoalCreate,
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    return crud.create_goal(db=db, goal=goal, user_id=current_user.id)

@app.get("/goals/", response_model=list[schemas.Goal])
def read_goals(
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    return crud.get_goals(db=db, user_id=current_user.id)

@app.post("/goals/{goal_id}/steps/", response_model=schemas.GoalStep)
def create_goal_step(
    goal_id: int,
    step: schemas.GoalStepCreate,
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    return crud.create_goal_step(db=db, step=step, goal_id=goal_id)

# Time Slot endpoints (for booking and reading slots)
@app.post("/time_slots/", response_model=schemas.TimeSlot)
def create_time_slot(
    time_slot: schemas.TimeSlotCreate,
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    return crud.create_time_slot(db=db, time_slot=time_slot, user_id=current_user.id)

@app.get("/time_slots/", response_model=list[schemas.TimeSlot])
def read_time_slots(
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    return crud.get_time_slots(db=db, user_id=current_user.id)

# Analytics endpoint: returns productivity metrics (e.g. total tasks and hours spent)
@app.get("/analytics/")
def get_analytics(
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    tasks = crud.get_tasks(db=db, user_id=current_user.id)
    total_tasks = len(tasks)
    completed_tasks = sum(1 for t in tasks if t.completed)
    total_time = sum(t.time_spent for t in tasks)
    return {
        "total_tasks": total_tasks,
        "completed_tasks": completed_tasks,
        "total_time_spent": total_time,
    }

# Stub: Customizable Dashboard Settings
@app.post("/dashboard/settings")
def update_dashboard_settings(
    settings: schemas.DashboardSettings,
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    # In a full implementation, save settings (theme, layout, etc.) in the DB.
    return {"msg": "Settings updated", "settings": settings}


@app.patch("/time_slots/{slot_id}", response_model=schemas.TimeSlot)
def patch_time_slot(
    slot_id: int,
    update: schemas.TimeSlotUpdate,
    db: Session = Depends(get_db),
    current_user: schemas.User = Depends(auth.get_current_user)
):
    slot = crud.get_time_slot(db, slot_id, current_user.id)
    if not slot:
        raise HTTPException(status_code=404, detail="Time slot not found")
    return crud.update_time_slot(db, slot, update)

@app.patch("/time_slots/{slot_id}")
def mark_time_slot_done(slot_id: int, done: bool, db: Session = Depends(get_db)):
    updated_slot = update_time_slot_done(db, slot_id, done)
    if updated_slot:
        return {"message": "Time slot updated successfully"}
    raise HTTPException(status_code=404, detail="Time slot not found")\n\n./app/database.py:\n
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

from .config import settings

SQLALCHEMY_DATABASE_URL = settings.DATABASE_URL

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()\n\n./app/models.py:\n
from sqlalchemy import Column, Integer, String, ForeignKey, Boolean, DateTime, Float
from sqlalchemy.orm import relationship
from datetime import datetime
from .database import Base

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    is_active = Column(Boolean, default=True)
    tasks = relationship("Task", back_populates="owner")
    goals = relationship("Goal", back_populates="owner")
    time_slots = relationship("TimeSlot", back_populates="owner")

class Task(Base):
    __tablename__ = "tasks"
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    description = Column(String, index=True)
    completed = Column(Boolean, default=False)
    time_spent = Column(Float, default=0.0)  # Time spent in hours
    owner_id = Column(Integer, ForeignKey("users.id"))
    owner = relationship("User", back_populates="tasks")

class Goal(Base):
    __tablename__ = "goals"
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    description = Column(String, index=True)
    completed = Column(Boolean, default=False)
    steps = relationship("GoalStep", back_populates="goal")
    owner_id = Column(Integer, ForeignKey("users.id"))
    owner = relationship("User", back_populates="goals")

class GoalStep(Base):
    __tablename__ = "goal_steps"
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    completed = Column(Boolean, default=False)
    goal_id = Column(Integer, ForeignKey("goals.id"))
    goal = relationship("Goal", back_populates="steps")


# app/models.py
from sqlalchemy import Column, Integer, String, ForeignKey, Boolean, DateTime, Float
from sqlalchemy.orm import relationship
from datetime import datetime
from .database import Base

class TimeSlot(Base):
    __tablename__ = "time_slots"
    id = Column(Integer, primary_key=True, index=True)
    start_time = Column(DateTime, index=True)
    end_time = Column(DateTime, index=True)
    description = Column(String, index=True)
    owner_id = Column(Integer, ForeignKey("users.id"))
    owner = relationship("User", back_populates="time_slots")
    
    # New columns for reporting and status.
    report_minutes = Column(Integer, default=0)
    done = Column(Boolean, default=False)
\n\n./app/crud.py:\n
# app/crud.py
from sqlalchemy.orm import Session
from . import models, schemas
from .utils import get_password_hash

def get_user(db: Session, user_id: int):
    return db.query(models.User).filter(models.User.id == user_id).first()

def get_user_by_email(db: Session, email: str):
    return db.query(models.User).filter(models.User.email == email).first()

def create_user(db: Session, user: schemas.UserCreate):
    hashed_password = get_password_hash(user.password)
    db_user = models.User(email=user.email, hashed_password=hashed_password)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def get_tasks(db: Session, user_id: int):
    return db.query(models.Task).filter(models.Task.owner_id == user_id).all()

def get_task(db: Session, task_id: int, user_id: int):
    return db.query(models.Task).filter(models.Task.id == task_id, models.Task.owner_id == user_id).first()

def create_task(db: Session, task: schemas.TaskCreate, user_id: int):
    db_task = models.Task(**task.dict(), owner_id=user_id)
    db.add(db_task)
    db.commit()
    db.refresh(db_task)
    return db_task

def update_task(db: Session, task: models.Task, task_update: schemas.TaskUpdate):
    if task_update.completed is not None:
        task.completed = task_update.completed
    if task_update.time_spent is not None:
        task.time_spent = task_update.time_spent
    db.commit()
    db.refresh(task)
    return task

def get_goals(db: Session, user_id: int):
    return db.query(models.Goal).filter(models.Goal.owner_id == user_id).all()

def create_goal(db: Session, goal: schemas.GoalCreate, user_id: int):
    db_goal = models.Goal(**goal.dict(), owner_id=user_id)
    db.add(db_goal)
    db.commit()
    db.refresh(db_goal)
    return db_goal

def create_goal_step(db: Session, step: schemas.GoalStepCreate, goal_id: int):
    db_step = models.GoalStep(**step.dict(), goal_id=goal_id)
    db.add(db_step)
    db.commit()
    db.refresh(db_step)
    return db_step

def get_time_slots(db: Session, user_id: int):
    return db.query(models.TimeSlot).filter(models.TimeSlot.owner_id == user_id).all()

def create_time_slot(db: Session, time_slot: schemas.TimeSlotCreate, user_id: int):
    db_time_slot = models.TimeSlot(**time_slot.dict(), owner_id=user_id)
    db.add(db_time_slot)
    db.commit()
    db.refresh(db_time_slot)
    return db_time_slot

def get_time_slot(db: Session, slot_id: int, user_id: int):
    return db.query(models.TimeSlot).filter(
        models.TimeSlot.id == slot_id,
        models.TimeSlot.owner_id == user_id
    ).first()

def update_time_slot(db: Session, slot: models.TimeSlot, update: schemas.TimeSlotUpdate):
    if update.report_minutes is not None:
        slot.report_minutes = update.report_minutes
    if update.done is not None:
        slot.done = update.done
    db.commit()
    db.refresh(slot)
    return slot


def update_time_slot_done(db: Session, slot_id: int, done: bool):
    time_slot = db.query(models.TimeSlot).filter(models.TimeSlot.id == slot_id).first()
    if time_slot:
        time_slot.done = done
        db.commit()
        db.refresh(time_slot)
        return time_slot
    return None\n\n./app/dependencies.py:\n
from .database import SessionLocal

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()